(() => {
var exports = {};
exports.id = 931;
exports.ids = [931];
exports.modules = {

/***/ 8038:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react");

/***/ }),

/***/ 8704:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react-dom/server-rendering-stub");

/***/ }),

/***/ 7897:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react-server-dom-webpack/client");

/***/ }),

/***/ 6786:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react/jsx-runtime");

/***/ }),

/***/ 5868:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/app-render");

/***/ }),

/***/ 1844:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/get-segment-param");

/***/ }),

/***/ 6624:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/future/helpers/interception-routes");

/***/ }),

/***/ 5281:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/future/route-modules/route-module");

/***/ }),

/***/ 7085:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/app-router-context");

/***/ }),

/***/ 1830:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/get-img-props");

/***/ }),

/***/ 199:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/hash");

/***/ }),

/***/ 6864:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/head");

/***/ }),

/***/ 9569:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/hooks-client-context");

/***/ }),

/***/ 2210:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/image-config");

/***/ }),

/***/ 5359:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/image-config-context");

/***/ }),

/***/ 7160:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router-context");

/***/ }),

/***/ 893:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/add-path-prefix");

/***/ }),

/***/ 7887:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/handle-smooth-scroll");

/***/ }),

/***/ 8735:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/is-bot");

/***/ }),

/***/ 8231:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/parse-path");

/***/ }),

/***/ 4614:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/path-has-prefix");

/***/ }),

/***/ 3750:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/remove-trailing-slash");

/***/ }),

/***/ 9618:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/server-inserted-html");

/***/ }),

/***/ 8658:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/utils/warn-once");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 914:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlobalError: () => (/* reexport default from dynamic */ next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_2___default.a),
/* harmony export */   __next_app__: () => (/* binding */ __next_app__),
/* harmony export */   originalPathname: () => (/* binding */ originalPathname),
/* harmony export */   pages: () => (/* binding */ pages),
/* harmony export */   routeModule: () => (/* binding */ routeModule),
/* harmony export */   tree: () => (/* binding */ tree)
/* harmony export */ });
/* harmony import */ var next_dist_server_future_route_modules_app_page_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7262);
/* harmony import */ var next_dist_server_future_route_modules_app_page_module__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_page_module__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9513);
/* harmony import */ var next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1823);
/* harmony import */ var next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2502);
/* harmony import */ var next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_3__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_3__) if(["default","tree","pages","GlobalError","originalPathname","__next_app__","routeModule"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
// @ts-ignore this need to be imported from next/dist to be external


const AppPageRouteModule = next_dist_server_future_route_modules_app_page_module__WEBPACK_IMPORTED_MODULE_0__.AppPageRouteModule;
// We inject the tree and pages here so that we can use them in the route
// module.
const tree = {
        children: [
        '',
        {
        children: ['__PAGE__', {}, {
          page: [() => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 2838)), "C:\\Users\\JoseP\\Documents\\landingMarketingPages\\ip-clone-best-daily-test\\app\\page.tsx"],
          metadata: {
    icon: [(async (props) => (await Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 7481))).default(props))],
    apple: [],
    openGraph: [],
    twitter: [],
    manifest: undefined
  }
        }]
      },
        {
        'layout': [() => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 1921)), "C:\\Users\\JoseP\\Documents\\landingMarketingPages\\ip-clone-best-daily-test\\app\\layout.tsx"],
'not-found': [() => Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 5493, 23)), "next/dist/client/components/not-found-error"],
        metadata: {
    icon: [(async (props) => (await Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 7481))).default(props))],
    apple: [],
    openGraph: [],
    twitter: [],
    manifest: undefined
  }
      }
      ]
      }.children;
const pages = ["C:\\Users\\JoseP\\Documents\\landingMarketingPages\\ip-clone-best-daily-test\\app\\page.tsx"];

// @ts-expect-error - replaced by webpack/turbopack loader

const __next_app_require__ = __webpack_require__
const __next_app_load_chunk__ = () => Promise.resolve()
const originalPathname = "/page";
const __next_app__ = {
    require: __next_app_require__,
    loadChunk: __next_app_load_chunk__
};

// Create and export the route module that will be consumed.
const routeModule = new AppPageRouteModule({
    definition: {
        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_PAGE,
        page: "/page",
        pathname: "/",
        // The following aren't used in production.
        bundlePath: "",
        filename: "",
        appPaths: []
    },
    userland: {
        loaderTree: tree
    }
});

//# sourceMappingURL=app-page.js.map

/***/ }),

/***/ 3583:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 6727))

/***/ }),

/***/ 6969:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 246))

/***/ }),

/***/ 9529:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 1232, 23));
Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 2987, 23));
Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 831, 23));
Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 6926, 23));
Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 4282, 23));
Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 6505, 23))

/***/ }),

/***/ 6727:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ Home)
});

// EXTERNAL MODULE: external "next/dist/compiled/react/jsx-runtime"
var jsx_runtime_ = __webpack_require__(6786);
// EXTERNAL MODULE: external "next/dist/compiled/react"
var react_ = __webpack_require__(8038);
// EXTERNAL MODULE: ./node_modules/next/image.js
var next_image = __webpack_require__(2451);
var image_default = /*#__PURE__*/__webpack_require__.n(next_image);
// EXTERNAL MODULE: ./node_modules/@livekit/components-react/dist/room-BBI9Ul2f.mjs
var room_BBI9Ul2f = __webpack_require__(9967);
// EXTERNAL MODULE: ./node_modules/@livekit/components-react/dist/components-DZxz2YwG.mjs + 1 modules
var components_DZxz2YwG = __webpack_require__(2548);
// EXTERNAL MODULE: ./node_modules/@livekit/components-styles/dist/general/index.css
var general = __webpack_require__(6894);
// EXTERNAL MODULE: ./node_modules/ai/react/dist/index.mjs + 3 modules
var dist = __webpack_require__(8384);
// EXTERNAL MODULE: ./node_modules/three/build/three.module.js
var three_module = __webpack_require__(437);
// EXTERNAL MODULE: ./node_modules/three/build/three.core.js
var three_core = __webpack_require__(1138);
;// CONCATENATED MODULE: ./app/components/BackgroundAnimation.tsx



const BackgroundAnimation = ()=>{
    const containerRef = (0,react_.useRef)(null);
    const rendererRef = (0,react_.useRef)(null);
    const sceneRef = (0,react_.useRef)(null);
    const cameraRef = (0,react_.useRef)(null);
    const cubesRef = (0,react_.useRef)([]);
    const velocitiesRef = (0,react_.useRef)([]);
    const timeRef = (0,react_.useRef)(0);
    const boundingSpheresRef = (0,react_.useRef)([]);
    (0,react_.useEffect)(()=>{
        if (!containerRef.current) return;
        // Add maximum speed constant
        const MAX_SPEED = 0.02; // Maximum speed for any direction
        // Helper function to limit velocity
        const limitVelocity = (velocity)=>{
            const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z);
            if (speed > MAX_SPEED) {
                const scale = MAX_SPEED / speed;
                velocity.x *= scale;
                velocity.y *= scale;
                velocity.z *= scale;
            }
        };
        // Setup
        const container = containerRef.current;
        const renderer = new three_module/* WebGLRenderer */.CP7({
            antialias: true,
            alpha: true
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);
        rendererRef.current = renderer;
        // Camera
        const fov = 75;
        const aspect = container.clientWidth / container.clientHeight;
        const near = 0.1;
        const far = 1000;
        const camera = new three_core/* PerspectiveCamera */.cPb(fov, aspect, near, far);
        camera.position.z = 8;
        cameraRef.current = camera;
        // Scene
        const scene = new three_core/* Scene */.xsS();
        sceneRef.current = scene;
        // Lighting
        const ambientLight = new three_core/* AmbientLight */.Mig(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new three_core/* DirectionalLight */.Ox3(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        // Add point lights for more subtle lighting
        const pointLight1 = new three_core/* PointLight */.cek(0x0072ff, 1.5, 20); // Reduced intensity, increased distance
        pointLight1.position.set(-5, 3, 5);
        scene.add(pointLight1);
        const pointLight2 = new three_core/* PointLight */.cek(0x8159ff, 1.5, 20); // Reduced intensity, increased distance
        pointLight2.position.set(5, -3, 5);
        scene.add(pointLight2);
        // Create a subtle fog
        scene.fog = new three_core/* FogExp2 */.yo9(0x090d19, 0.03);
        // Create cubes with modern materials
        const geometryOptions = [
            new three_core/* BoxGeometry */.DvJ(1, 1, 1),
            new three_core/* IcosahedronGeometry */.cJO(0.8, 0),
            new three_core/* OctahedronGeometry */.pQR(0.8),
            new three_core/* TetrahedronGeometry */.H$k(0.9)
        ];
        // Modern tech-inspired colors
        const colors = [
            0x0072ff,
            0x8159ff,
            0x2dd4bf,
            0x0ea5e9,
            0x8b5cf6,
            0x3b82f6,
            0x0284c7,
            0x2563eb,
            0x7c3aed,
            0x6366f1 // Indigo
        ];
        for(let i = 0; i < 15; i++){
            // Randomly select a geometry
            const geometry = geometryOptions[Math.floor(Math.random() * geometryOptions.length)];
            // Create glassy material
            const material = new three_core/* MeshPhysicalMaterial */.EJi({
                color: colors[i % colors.length],
                transparent: true,
                opacity: 0.6,
                metalness: 0.2,
                roughness: 0.25,
                clearcoat: 0.5,
                clearcoatRoughness: 0.2,
                wireframe: Math.random() > 0.9
            });
            const cube = new three_core/* Mesh */.Kj0(geometry, material);
            // Random size
            const scale = 0.5 + Math.random() * 0.7;
            cube.scale.set(scale, scale, scale);
            // Random initial position (wider spread)
            cube.position.x = (Math.random() - 0.5) * 16;
            cube.position.y = (Math.random() - 0.5) * 16;
            cube.position.z = (Math.random() - 0.5) * 16;
            // Create a bounding sphere for collision detection
            // Size the bounding sphere based on the object's scale
            const boundingSphere = new three_core/* Sphere */.aLr(cube.position.clone(), scale * 0.8 // Slightly smaller than the visual size for better visual collisions
            );
            boundingSpheresRef.current.push(boundingSphere);
            // Random initial velocity (much slower)
            velocitiesRef.current.push({
                x: (Math.random() - 0.5) * 0.006,
                y: (Math.random() - 0.5) * 0.006,
                z: (Math.random() - 0.5) * 0.006
            });
            scene.add(cube);
            cubesRef.current.push(cube);
        }
        // Animation
        const animate = (time)=>{
            timeRef.current = time * 0.001; // Convert to seconds
            requestAnimationFrame(animate);
            // Slowly rotate camera
            const cameraRadius = 10;
            const cameraSpeed = 0.02; // Reduced from 0.05 to 0.02
            if (cameraRef.current) {
                cameraRef.current.position.x = Math.sin(timeRef.current * cameraSpeed) * cameraRadius;
                cameraRef.current.position.z = Math.cos(timeRef.current * cameraSpeed) * cameraRadius;
                cameraRef.current.lookAt(0, 0, 0);
            }
            // First, update positions
            cubesRef.current.forEach((cube, index)=>{
                const velocity = velocitiesRef.current[index];
                // Update position
                cube.position.x += velocity.x;
                cube.position.y += velocity.y;
                cube.position.z += velocity.z;
                // Update bounding sphere position
                boundingSpheresRef.current[index].center.copy(cube.position);
                // Bounce off boundaries
                if (Math.abs(cube.position.x) > 8) velocity.x *= -1;
                if (Math.abs(cube.position.y) > 8) velocity.y *= -1;
                if (Math.abs(cube.position.z) > 8) velocity.z *= -1;
                // Unique rotation for each cube
                cube.rotation.x += 0.002 + index * 0.0001;
                cube.rotation.y += 0.003 + index * 0.00005;
                cube.rotation.z += 0.0025 + index * 0.0001;
                // Pulse scale effect based on sine wave
                const pulseSpeed = 0.15 + index * 0.01;
                const pulseStrength = 0.03;
                const basescale = 0.5 + index % 5 * 0.1;
                const pulse = Math.sin(timeRef.current * pulseSpeed) * pulseStrength;
                const newScale = basescale + pulse;
                cube.scale.set(newScale, newScale, newScale);
                // Update bounding sphere radius with pulsing effect
                boundingSpheresRef.current[index].radius = newScale * 0.8;
            });
            // Check for collisions between all pairs of objects
            for(let i = 0; i < cubesRef.current.length; i++){
                for(let j = i + 1; j < cubesRef.current.length; j++){
                    const sphere1 = boundingSpheresRef.current[i];
                    const sphere2 = boundingSpheresRef.current[j];
                    // Calculate distance between sphere centers
                    const distance = sphere1.center.distanceTo(sphere2.center);
                    const minDistance = sphere1.radius + sphere2.radius;
                    // If spheres are colliding
                    if (distance < minDistance) {
                        // Get the objects and their velocities
                        const obj1 = cubesRef.current[i];
                        const obj2 = cubesRef.current[j];
                        const vel1 = velocitiesRef.current[i];
                        const vel2 = velocitiesRef.current[j];
                        // Calculate collision normal
                        const normal = new three_core/* Vector3 */.Pa4().subVectors(sphere2.center, sphere1.center).normalize();
                        // Apply impulse-based collision response
                        // Calculate relative velocity
                        const relativeVelocity = new three_core/* Vector3 */.Pa4(vel2.x - vel1.x, vel2.y - vel1.y, vel2.z - vel1.z);
                        // Calculate impulse scale
                        const impulseScale = 1.5; // Can be adjusted for more "bouncy" collisions
                        const impulse = relativeVelocity.dot(normal) * impulseScale;
                        // Apply impulse to velocities
                        vel1.x += normal.x * impulse;
                        vel1.y += normal.y * impulse;
                        vel1.z += normal.z * impulse;
                        vel2.x -= normal.x * impulse;
                        vel2.y -= normal.y * impulse;
                        vel2.z -= normal.z * impulse;
                        // Limit velocities after collision
                        limitVelocity(vel1);
                        limitVelocity(vel2);
                        // Move objects apart slightly to prevent sticking
                        const moveScale = (minDistance - distance) / 2;
                        obj1.position.x -= normal.x * moveScale;
                        obj1.position.y -= normal.y * moveScale;
                        obj1.position.z -= normal.z * moveScale;
                        obj2.position.x += normal.x * moveScale;
                        obj2.position.y += normal.y * moveScale;
                        obj2.position.z += normal.z * moveScale;
                        // Update bounding spheres after moving objects
                        boundingSpheresRef.current[i].center.copy(obj1.position);
                        boundingSpheresRef.current[j].center.copy(obj2.position);
                    }
                }
            }
            renderer.render(scene, camera);
        };
        // Handle window resize
        const handleResize = ()=>{
            if (!containerRef.current || !cameraRef.current || !rendererRef.current) return;
            const container = containerRef.current;
            const camera = cameraRef.current;
            const renderer = rendererRef.current;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        };
        window.addEventListener("resize", handleResize);
        animate(0);
        // Cleanup
        return ()=>{
            window.removeEventListener("resize", handleResize);
            if (containerRef.current && rendererRef.current) {
                containerRef.current.removeChild(rendererRef.current.domElement);
            }
            cubesRef.current = [];
            velocitiesRef.current = [];
            boundingSpheresRef.current = [];
        };
    }, []);
    return /*#__PURE__*/ jsx_runtime_.jsx("div", {
        ref: containerRef,
        className: "background-animation"
    });
};
/* harmony default export */ const components_BackgroundAnimation = (BackgroundAnimation);

;// CONCATENATED MODULE: ./app/components/SoundEffects.ts
// SoundEffects.ts - Utility for playing sound effects in the application
const playSoundEffect = (soundUrl)=>{
    try {
        const audio = new Audio(soundUrl);
        audio.play().catch((error)=>{
            console.error("Error playing sound effect:", error);
        });
    } catch (error) {
        console.error("Error initializing audio:", error);
    }
};
// Sound effect utility functions
const playTransformersSound = ()=>{
    playSoundEffect("/transformers-sound.mp3");
};
const playGameEndSound = ()=>{
    playSoundEffect("/game-end.mp3");
};
/* harmony default export */ const SoundEffects = ({
    playTransformersSound,
    playGameEndSound
});

;// CONCATENATED MODULE: ./app/components/AudioChat.tsx
/* __next_internal_client_entry_do_not_use__ default auto */ 







const TypeWriter = ({ text })=>{
    const [displayedText, setDisplayedText] = (0,react_.useState)("");
    const intervalRef = (0,react_.useRef)(null);
    (0,react_.useEffect)(()=>{
        setDisplayedText(""); // Reset text when prop changes
        let currentText = "";
        let currentIndex = 0;
        const streamText = ()=>{
            if (currentIndex < text.length) {
                currentText += text[currentIndex];
                setDisplayedText(currentText);
                currentIndex++;
            } else {
                if (intervalRef.current) {
                    window.clearInterval(intervalRef.current);
                }
            }
        };
        intervalRef.current = window.setInterval(streamText, 50);
        return ()=>{
            if (intervalRef.current) {
                window.clearInterval(intervalRef.current);
            }
        };
    }, [
        text
    ]);
    return /*#__PURE__*/ jsx_runtime_.jsx("h2", {
        className: "typewriter-text",
        children: displayedText
    });
};
const AudioChat = ({ initialText })=>{
    const [isConnected, setIsConnected] = (0,react_.useState)(false);
    const [error, setError] = (0,react_.useState)(null);
    const [token, setToken] = (0,react_.useState)(null);
    const [roomName, setRoomName] = (0,react_.useState)(null);
    const [wsUrl, setWsUrl] = (0,react_.useState)(null);
    const [isRecording, setIsRecording] = (0,react_.useState)(false);
    const [isProcessing, setIsProcessing] = (0,react_.useState)(false);
    const [messages, setMessages] = (0,react_.useState)([]);
    const [isUIReady, setIsUIReady] = (0,react_.useState)(false);
    const [isInterviewComplete, setIsInterviewComplete] = (0,react_.useState)(false);
    // Use the useChat hook for better message handling
    const { append, messages: chatMessages } = (0,dist/* useChat */.RJ)({
        api: "/api/openai-gpt",
        onFinish: (message)=>{
            // Only speak the complete message when it's fully received
            if (message.role === "assistant") {
                speakText(message.content).catch(console.error);
                // Check if this is the final message (contains the goodbye message)
                // Look for the key phrases that indicate the interview is complete
                if (message.content.includes("Thank you for your time") && message.content.includes("have a great day")) {
                    setIsInterviewComplete(true);
                }
            }
        }
    });
    // MediaRecorder setup
    const mediaRecorder = (0,react_.useRef)(null);
    const audioChunks = (0,react_.useRef)([]);
    // Add ref for messages container
    const messagesEndRef = (0,react_.useRef)(null);
    // Scroll to bottom when messages change
    (0,react_.useEffect)(()=>{
        messagesEndRef.current?.scrollIntoView({
            behavior: "smooth"
        });
    }, [
        messages
    ]);
    // Play transformers sound when loading
    (0,react_.useEffect)(()=>{
        if (!isConnected || !token || !roomName || !wsUrl) {
            playTransformersSound();
        }
    }, [
        isConnected,
        token,
        roomName,
        wsUrl
    ]);
    // Play game-end sound when interview is complete
    (0,react_.useEffect)(()=>{
        if (isInterviewComplete) {
            playGameEndSound();
        }
    }, [
        isInterviewComplete
    ]);
    // Function to send text to speech
    const speakText = async (text)=>{
        try {
            // Create a new SpeechSynthesisUtterance
            const utterance = new SpeechSynthesisUtterance(text);
            // Set some properties for better speech
            utterance.rate = 1.0; // Speed of speech
            utterance.pitch = 1.0; // Pitch of voice
            utterance.volume = 1.0; // Volume
            // Return a promise that resolves when the speech is complete
            return new Promise((resolve, reject)=>{
                utterance.onend = ()=>{
                    console.log("Finished speaking chunk");
                    console.log("Text-to-speech completed successfully");
                    resolve();
                };
                utterance.onerror = (error)=>{
                    console.error("Error in text-to-speech:", error);
                    reject(error);
                };
                // Start speaking
                console.log("Starting to speak:", text);
                window.speechSynthesis.speak(utterance);
            });
        } catch (error) {
            console.error("Error in text-to-speech:", error);
        }
    };
    // Function to send message to OpenAI and speak
    const sendMessageToOpenAI = async (messageContent, role = "user")=>{
        try {
            // If it's a system message (like the initial greeting), speak it directly
            if (role === "system") {
                setMessages((prev)=>[
                        ...prev,
                        {
                            role,
                            content: messageContent
                        }
                    ]);
                await speakText(messageContent);
                return;
            }
            // For user messages, use the useChat hook's append function
            await append({
                content: messageContent,
                role: "user"
            });
        } catch (error) {
            console.error("Error in sendMessageToOpenAI:", error);
            setError("Failed to get AI response");
        }
    };
    // Update messages when chat messages change
    (0,react_.useEffect)(()=>{
        if (chatMessages.length > 0) {
            setMessages(chatMessages);
        // We no longer trigger speech here since we're using onFinish
        // The UI will still update progressively with the stream
        }
    }, [
        chatMessages
    ]);
    (0,react_.useEffect)(()=>{
        const setupRoom = async ()=>{
            try {
                console.log("Setting up room...");
                const generatedRoomName = `interview-${Math.random().toString(36).substring(2, 8)}`;
                setRoomName(generatedRoomName);
                const response = await fetch("/api/agent", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        roomName: generatedRoomName,
                        participantName: "User"
                    })
                });
                if (!response.ok) {
                    throw new Error("Failed to get token");
                }
                const data = await response.json();
                console.log("API Response:", data);
                if (!data.token || typeof data.token !== "string") {
                    throw new Error("Invalid token received from server");
                }
                if (!data.wsUrl) {
                    throw new Error("WebSocket URL not received from server");
                }
                setToken(data.token);
                setWsUrl(data.wsUrl);
                setIsConnected(true);
                setIsUIReady(true); // Mark UI as ready after connection is established
                // Send initial message after UI is ready
                const initialMessage = initialText ?? "Hello, I am Bob the Interviewer. How can I help you?";
                await sendMessageToOpenAI(initialMessage, "system");
            } catch (err) {
                console.error("Error setting up room:", err);
                setError(err instanceof Error ? err.message : "Failed to connect to interview room");
            }
        };
        setupRoom();
    }, [
        initialText
    ]);
    // Initialize MediaRecorder
    (0,react_.useEffect)(()=>{
        const initMediaRecorder = async ()=>{
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: true
                });
                mediaRecorder.current = new MediaRecorder(stream);
                mediaRecorder.current.ondataavailable = (event)=>{
                    if (event.data.size > 0) {
                        audioChunks.current.push(event.data);
                    }
                };
                mediaRecorder.current.onstop = async ()=>{
                    setIsProcessing(true);
                    try {
                        const audioBlob = new Blob(audioChunks.current, {
                            type: "audio/wav"
                        });
                        audioChunks.current = [];
                        // Create form data with the audio file
                        const formData = new FormData();
                        formData.append("audio", audioBlob, "recording.wav");
                        // Send audio to speech-to-text endpoint
                        const transcriptionResponse = await fetch("/api/speech-to-text", {
                            method: "POST",
                            body: formData
                        });
                        if (!transcriptionResponse.ok) {
                            throw new Error("Failed to transcribe audio");
                        }
                        const { text: transcribedText } = await transcriptionResponse.json();
                        console.log("Transcribed text:", transcribedText);
                        // Send transcribed text to OpenAI
                        await sendMessageToOpenAI(transcribedText);
                    } catch (error) {
                        console.error("Error processing audio:", error);
                        setError("Failed to process audio");
                    } finally{
                        setIsProcessing(false);
                    }
                };
            } catch (err) {
                console.error("Error initializing media recorder:", err);
                setError("Failed to access microphone");
            }
        };
        if (isConnected) {
            initMediaRecorder();
        }
    }, [
        isConnected
    ]);
    const toggleRecording = ()=>{
        if (!mediaRecorder.current) {
            console.error("MediaRecorder not initialized");
            return;
        }
        if (isRecording) {
            mediaRecorder.current.stop();
        } else {
            audioChunks.current = [];
            mediaRecorder.current.start();
        }
        setIsRecording(!isRecording);
    };
    if (error) {
        return /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
            className: "error-container",
            children: [
                /*#__PURE__*/ (0,jsx_runtime_.jsxs)("p", {
                    children: [
                        "Error: ",
                        error
                    ]
                }),
                /*#__PURE__*/ jsx_runtime_.jsx("button", {
                    onClick: ()=>window.location.reload(),
                    children: "Retry Connection"
                })
            ]
        });
    }
    if (!isConnected || !token || !roomName || !wsUrl) {
        return /*#__PURE__*/ jsx_runtime_.jsx("div", {
            className: "loading-container",
            children: /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                className: "loading-message",
                children: [
                    /*#__PURE__*/ jsx_runtime_.jsx("div", {
                        className: "robot-image-container",
                        children: /*#__PURE__*/ jsx_runtime_.jsx((image_default()), {
                            src: "/MegaRobotInterviewer.png",
                            alt: "Robot Interviewer",
                            width: 480,
                            height: 480,
                            priority: true
                        })
                    }),
                    /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                        className: "loading-text",
                        children: [
                            /*#__PURE__*/ jsx_runtime_.jsx(TypeWriter, {
                                text: "Hello! I'm your interviewer today. I'll be reviewing your resume and asking you some questions."
                            }),
                            /*#__PURE__*/ jsx_runtime_.jsx("h3", {
                                children: "Connecting to interview room..."
                            }),
                            /*#__PURE__*/ jsx_runtime_.jsx("div", {
                                className: "loading-spinner"
                            })
                        ]
                    })
                ]
            })
        });
    }
    return /*#__PURE__*/ (0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
        children: [
            /*#__PURE__*/ jsx_runtime_.jsx(components_BackgroundAnimation, {}),
            /*#__PURE__*/ jsx_runtime_.jsx("div", {
                className: "audio-chat-container",
                children: /*#__PURE__*/ (0,jsx_runtime_.jsxs)(room_BBI9Ul2f.L, {
                    token: token,
                    serverUrl: wsUrl,
                    connect: true,
                    onConnected: ()=>{
                        console.log("Connected to LiveKit room:", roomName);
                    },
                    onDisconnected: ()=>{
                        console.log("Disconnected from LiveKit room:", roomName);
                    },
                    onError: (error)=>{
                        console.error("LiveKit room error:", error);
                        setError(error.message);
                    },
                    children: [
                        /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                            className: "chat-layout",
                            children: [
                                /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                                    className: "chat-header",
                                    children: [
                                        /*#__PURE__*/ jsx_runtime_.jsx("h2", {
                                            children: "Interview with Bob"
                                        }),
                                        /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                                            className: "status-indicator",
                                            children: [
                                                /*#__PURE__*/ jsx_runtime_.jsx("span", {
                                                    className: `status-dot ${isConnected ? "connected" : "disconnected"}`
                                                }),
                                                isConnected ? "Connected" : "Disconnected"
                                            ]
                                        })
                                    ]
                                }),
                                /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                                    className: "messages-container",
                                    children: [
                                        messages.map((message, index)=>/*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                                                className: `message-wrapper ${message.role === "user" ? "user-message" : "bob-message"}`,
                                                children: [
                                                    /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                                                        className: "message-content",
                                                        children: [
                                                            /*#__PURE__*/ jsx_runtime_.jsx("div", {
                                                                className: "message-sender",
                                                                children: message.role === "system" || message.role === "assistant" ? "Bob" : "You"
                                                            }),
                                                            /*#__PURE__*/ jsx_runtime_.jsx("div", {
                                                                className: "message-text",
                                                                children: message.content
                                                            })
                                                        ]
                                                    }),
                                                    /*#__PURE__*/ jsx_runtime_.jsx("div", {
                                                        className: "message-timestamp",
                                                        children: new Date().toLocaleTimeString([], {
                                                            hour: "2-digit",
                                                            minute: "2-digit"
                                                        })
                                                    })
                                                ]
                                            }, index)),
                                        /*#__PURE__*/ jsx_runtime_.jsx("div", {
                                            ref: messagesEndRef
                                        })
                                    ]
                                }),
                                /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                                    className: "chat-controls",
                                    children: [
                                        /*#__PURE__*/ (0,jsx_runtime_.jsxs)("button", {
                                            className: `record-button ${isRecording ? "recording" : ""} ${isProcessing ? "processing" : ""} ${isInterviewComplete ? "interview-complete" : ""}`,
                                            onClick: toggleRecording,
                                            disabled: isProcessing || isInterviewComplete,
                                            children: [
                                                /*#__PURE__*/ jsx_runtime_.jsx("span", {
                                                    className: "button-icon",
                                                    children: isRecording ? "⏹" : isProcessing ? "⌛" : isInterviewComplete ? "✅" : "\uD83C\uDFA4"
                                                }),
                                                /*#__PURE__*/ jsx_runtime_.jsx("span", {
                                                    className: "button-text",
                                                    children: isProcessing ? "Processing..." : isRecording ? "Stop Recording" : isInterviewComplete ? "Interview Complete" : "Start Recording"
                                                })
                                            ]
                                        }),
                                        isInterviewComplete && /*#__PURE__*/ (0,jsx_runtime_.jsxs)("button", {
                                            className: "new-interview-button",
                                            onClick: ()=>window.location.reload(),
                                            children: [
                                                /*#__PURE__*/ jsx_runtime_.jsx("span", {
                                                    className: "button-icon",
                                                    children: "\uD83D\uDD04"
                                                }),
                                                /*#__PURE__*/ jsx_runtime_.jsx("span", {
                                                    className: "button-text",
                                                    children: "Start New Interview"
                                                })
                                            ]
                                        })
                                    ]
                                })
                            ]
                        }),
                        /*#__PURE__*/ jsx_runtime_.jsx(components_DZxz2YwG.R, {})
                    ]
                })
            })
        ]
    });
};
/* harmony default export */ const components_AudioChat = (AudioChat);

;// CONCATENATED MODULE: ./app/components/ResumeUploader.tsx



const ResumeUploader = ({ onChatStart })=>{
    const [showChat, setShowChat] = (0,react_.useState)(false);
    const [isLoading, setIsLoading] = (0,react_.useState)(false);
    const [initialText, setInitialText] = (0,react_.useState)("");
    const [isDragging, setIsDragging] = (0,react_.useState)(false);
    const fileInputRef = (0,react_.useRef)(null);
    // Add a class to body when chat is shown
    (0,react_.useEffect)(()=>{
        if (showChat) {
            document.body.classList.add("chat-active");
            onChatStart?.();
        } else {
            document.body.classList.remove("chat-active");
        }
        return ()=>{
            document.body.classList.remove("chat-active");
        };
    }, [
        showChat,
        onChatStart
    ]);
    const handleResumeUpload = async (event)=>{
        setIsLoading(true);
        const file = event.target.files?.[0];
        if (!file) {
            console.error("No file selected");
            setIsLoading(false);
            return;
        }
        await processFile(file);
    };
    const processFile = async (file)=>{
        if (file.type !== "application/pdf") {
            alert("Please upload a PDF file");
            setIsLoading(false);
            return;
        }
        const formData = new FormData();
        formData.append("file", file);
        try {
            const response = await fetch("/api/extract-text", {
                method: "POST",
                body: formData
            });
            if (!response.ok) {
                throw new Error("Network response was not ok");
            }
            const { text: extractedText } = await response.json();
            setInitialText(extractedText);
            setShowChat(true);
        } catch (error) {
            console.error("Error processing resume:", error);
        } finally{
            setIsLoading(false);
        }
    };
    const handleDragOver = (e)=>{
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    };
    const handleDragLeave = (e)=>{
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    };
    const handleDrop = async (e)=>{
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
        setIsLoading(true);
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            await processFile(files[0]);
        } else {
            setIsLoading(false);
        }
    };
    return /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
        children: [
            /*#__PURE__*/ jsx_runtime_.jsx("p", {
                className: "instructions-text",
                children: !showChat ? "Upload your resume to start the interview." : "Answer Bob's questions using your microphone."
            }),
            !showChat ? /*#__PURE__*/ (0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
                children: [
                    /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                        className: `file-upload-btn-container ${isDragging ? "dragging" : ""}`,
                        onDragOver: handleDragOver,
                        onDragLeave: handleDragLeave,
                        onDrop: handleDrop,
                        children: [
                            /*#__PURE__*/ jsx_runtime_.jsx("input", {
                                type: "file",
                                id: "file-upload",
                                onChange: handleResumeUpload,
                                accept: "application/pdf",
                                hidden: true,
                                ref: fileInputRef
                            }),
                            /*#__PURE__*/ (0,jsx_runtime_.jsxs)("label", {
                                htmlFor: "file-upload",
                                className: "file-upload-btn",
                                children: [
                                    "\uD83D\uDCC4 ",
                                    isDragging ? "Drop Resume Here" : "Upload Resume"
                                ]
                            }),
                            /*#__PURE__*/ jsx_runtime_.jsx("p", {
                                className: "drag-drop-hint",
                                children: "or drag and drop a PDF file here"
                            })
                        ]
                    }),
                    isLoading && /*#__PURE__*/ jsx_runtime_.jsx("div", {
                        className: "loading-spinner"
                    })
                ]
            }) : /*#__PURE__*/ jsx_runtime_.jsx(components_AudioChat, {
                initialText: initialText
            })
        ]
    });
};
/* harmony default export */ const components_ResumeUploader = (ResumeUploader);

;// CONCATENATED MODULE: ./app/page.tsx
/* __next_internal_client_entry_do_not_use__ default auto */ 



function Home() {
    const [isChatActive, setIsChatActive] = (0,react_.useState)(false);
    return /*#__PURE__*/ (0,jsx_runtime_.jsxs)("main", {
        className: "App",
        children: [
            /*#__PURE__*/ jsx_runtime_.jsx(components_BackgroundAnimation, {}),
            /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                className: "container",
                children: [
                    /*#__PURE__*/ (0,jsx_runtime_.jsxs)("h1", {
                        className: "app-title",
                        children: [
                            "Interview",
                            /*#__PURE__*/ jsx_runtime_.jsx("span", {
                                className: "span-primary",
                                children: "Pro"
                            })
                        ]
                    }),
                    /*#__PURE__*/ jsx_runtime_.jsx("p", {
                        className: "instructions-text",
                        children: "Upload your resume and start a personalized interview session with our AI interviewer. Get real-time feedback and improve your interview skills."
                    }),
                    /*#__PURE__*/ jsx_runtime_.jsx(components_ResumeUploader, {
                        onChatStart: ()=>setIsChatActive(true)
                    }),
                    !isChatActive && /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                        className: "features-grid",
                        children: [
                            /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                                className: "feature-card",
                                children: [
                                    /*#__PURE__*/ jsx_runtime_.jsx("div", {
                                        className: "feature-icon",
                                        children: "\uD83C\uDF99️"
                                    }),
                                    /*#__PURE__*/ jsx_runtime_.jsx("h3", {
                                        children: "Voice Interaction"
                                    }),
                                    /*#__PURE__*/ jsx_runtime_.jsx("p", {
                                        children: "Natural conversation with advanced speech recognition"
                                    })
                                ]
                            }),
                            /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                                className: "feature-card",
                                children: [
                                    /*#__PURE__*/ jsx_runtime_.jsx("div", {
                                        className: "feature-icon",
                                        children: "\uD83E\uDDE0"
                                    }),
                                    /*#__PURE__*/ jsx_runtime_.jsx("h3", {
                                        children: "AI Feedback"
                                    }),
                                    /*#__PURE__*/ jsx_runtime_.jsx("p", {
                                        children: "Personalized guidance based on your responses"
                                    })
                                ]
                            }),
                            /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                                className: "feature-card",
                                children: [
                                    /*#__PURE__*/ jsx_runtime_.jsx("div", {
                                        className: "feature-icon",
                                        children: "\uD83D\uDCDD"
                                    }),
                                    /*#__PURE__*/ jsx_runtime_.jsx("h3", {
                                        children: "Resume Analysis"
                                    }),
                                    /*#__PURE__*/ jsx_runtime_.jsx("p", {
                                        children: "Questions tailored to your experience and skills"
                                    })
                                ]
                            })
                        ]
                    })
                ]
            })
        ]
    });
}


/***/ }),

/***/ 1921:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RootLayout),
/* harmony export */   metadata: () => (/* binding */ metadata)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6786);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_font_google_target_css_path_app_layout_tsx_import_Space_Grotesk_arguments_subsets_latin_display_swap_variable_font_space_grotesk_weight_400_500_600_700_variableName_spaceGrotesk___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5766);
/* harmony import */ var next_font_google_target_css_path_app_layout_tsx_import_Space_Grotesk_arguments_subsets_latin_display_swap_variable_font_space_grotesk_weight_400_500_600_700_variableName_spaceGrotesk___WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_font_google_target_css_path_app_layout_tsx_import_Space_Grotesk_arguments_subsets_latin_display_swap_variable_font_space_grotesk_weight_400_500_600_700_variableName_spaceGrotesk___WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7272);
/* harmony import */ var _globals_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_globals_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _vercel_analytics_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3069);




const metadata = {
    title: "InterviewPro - AI-Powered Interview Training",
    description: "Practice behavioral interviews with our AI-powered interviewer. Get real-time feedback and improve your interview skills."
};
function RootLayout({ children }) {
    return /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx("html", {
        lang: "en",
        className: (next_font_google_target_css_path_app_layout_tsx_import_Space_Grotesk_arguments_subsets_latin_display_swap_variable_font_space_grotesk_weight_400_500_600_700_variableName_spaceGrotesk___WEBPACK_IMPORTED_MODULE_3___default().variable),
        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("body", {
            className: (next_font_google_target_css_path_app_layout_tsx_import_Space_Grotesk_arguments_subsets_latin_display_swap_variable_font_space_grotesk_weight_400_500_600_700_variableName_spaceGrotesk___WEBPACK_IMPORTED_MODULE_3___default().className),
            children: [
                children,
                /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_vercel_analytics_react__WEBPACK_IMPORTED_MODULE_2__/* .Analytics */ .c, {})
            ]
        })
    });
}


/***/ }),

/***/ 2838:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $$typeof: () => (/* binding */ $$typeof),
/* harmony export */   __esModule: () => (/* binding */ __esModule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1363);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\JoseP\Documents\landingMarketingPages\ip-clone-best-daily-test\app\page.tsx`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__default__);

/***/ }),

/***/ 7481:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_lib_metadata_get_metadata_route__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85);
/* harmony import */ var next_dist_lib_metadata_get_metadata_route__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_metadata_get_metadata_route__WEBPACK_IMPORTED_MODULE_0__);
  

  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((props) => {
    const imageData = {"type":"image/x-icon","sizes":"64x64"}
    const imageUrl = (0,next_dist_lib_metadata_get_metadata_route__WEBPACK_IMPORTED_MODULE_0__.fillMetadataSegment)(".", props.params, "favicon.ico")

    return [{
      ...imageData,
      url: imageUrl + "",
    }]
  });

/***/ }),

/***/ 7272:
/***/ (() => {



/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, [587,715], () => (__webpack_exec__(914)));
module.exports = __webpack_exports__;

})();